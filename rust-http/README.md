이번 프로젝트에선
RUST & HTTP/1.1 서버 구현해보기
HTTP/1.1은
1.어플리케이션 레이어 프로토콜 또는 L7 프로토콜
2.TCP클라이언트 서버를 통해 전송
3.스트리밍 데이터가 아닌 개별 메세지를 교환해서 통신

----------------------------------------------------------------------------

러스트에는 두가지 타입의 문자열이 있음
str은 문자열 슬라이스 -> 어떤 문자열에 대한 이뮤터블한 참조

새로운 문자열을 만들려면 let string = String::new() 함수 호출
let string = String::from()도 존재
문자열 슬라이스를 이용하면 우리가 서버에서 받을 요청들을 효율적으로 분해할 수 있음.
만약 문자열 슬라이스를 받는 함수에 문자열을 넣으려고 한다면,컴파일러는 문자열을 문자열 슬라이스로 변환하고 그러 함수에 넣어줌
let string_literal = "1234"; 같은 경우에 컴파일링 시점에 이미 string_literal이 알려져 있기 때문에 우린 코드를 컴파일링 하기 전에 컴파일러에게 그걸 알려준다. => 그럼 컴파일러는 이걸 바이너리 자체로 구워낸다. => 이 문자열이 실제로 있는 곳은 메모리 안 일 것이다.

let string_slice = &string[10..]; 이런 리터럴 인덱스를 이용해서 문자열을 자르고 싶지 않다. => 러스트의 모든 문자열은 UTF-8로 인코딩 되어 있기 때문 => 문자열에 있는 한 문자가 항상 1바이트를 차지하는지 확실하지 않다는 의미. => 보통은 알파벳,숫자 등은 1바이트로 되어있지만 일본어 기호,이모티콘 같은건 1바이트 이상을 차지하는 경우가 있어 let string = String::from("🚚🎱👸🔥");  [src/main.rs:8:5] string_slice = "🚚" 이런 경우가 있음
이모티콘은 1바이트가 아닌 4바이트로 인코딩 되기 때문이다.
그래서 일반적으로 우리가 실제 애플리케이션을 작성할때 이렇게 직접 문자열을 자르지 않길 원함.

----------------------------------------------------------------------------

GET /user?id=10 HTTP/1.1\r\n
HEADERS \r\n
BODY
구현해보자

ENUM은 유한한 값 집합을 갖고 있는 툭수한 타입  RUST의 ENUM은 Haskell의 대수 자료형과 아주 비슷함
메모리 안에서는 enum의 베리언트가 단순한 숫자로 표시
enum Method {
    GET,
    DELETE,
    POST,
    PUT,
    HEAD,
    CONNECT,
    OPTIONS,
    TRACE,
    PATCH,
    
}
를 봤을때 Method가 GET이라면 메모리에서 우린 그냥 0을 저장,DELETE라면 1을 저장

RUST는 NO VALUE를 지원하지 않는다.하지만 비록 RUST가 언어에서 NO를 삭제하기로 했지만 값이 없다는걸 어떻게든 표현하길 원함 => RUST는 완벽히 타입에 안전한 방식으로 그걸함,표준 라이브러리의 특수 enum인 Option을 사용
query_string: Option<String>는 이게 String에 대해 제네릭한 Option이라는걸 컴파일러에게 알려주는것! -> 컴파일러는 String을 담는 Option enum에 필요한 공간을 할당
이런 방식으로 하면 우리는 예외가 발생할 걸 걱정하지 않고 타입에 대해 안전한 방식으로 값이 어떻게 표현되는지 알 수 있음

--------------------------------------------------------------------------------------------------------------------------------------------------------
점점 main.rs에 파일이 커지고 있어 -> 프로그램이 커지면 그걸 둘 이상의 파일로 나누고 기능과 타입들을 다른 네임스페이스에 넣어줄 필요가 있음 -> RUST에선 모듈이라고 부름 
모듈은 아이템들의 가시성을 통제함 뿐만 아니라 즉 아이템의 코드를 바깥에서도 사용할 수 있는지를 말함
폴더를 만들고 모듈을 분리함으로써 가독성 , 코드가 다수의 모듈로 정리가 됨 => 모듈은 정리하고 가시성을 높이자!!


--------------------------------------------------------------------------------------------------------------------------------------------------------
TCP연결

TcpListener는 Result을 리턴 => Result리턴은 RUST에서 오류처리(에러핸들링)의 핵심

RUST가 다른언어와 다른점은 RUST는 우리가 오류의 가능성을 인식하고 코드가 성공적으로 컴파일링 되기전 약간의 조치를 취하길 요구한다는 점이다! 이를 통해 우리는 오류를 적절히 처리하게 함으로써 프로그램을 더욱 강건하게 만들어준다
RUST의 오류는 두가지로 구분.
1.복구 가능한 오류 => File Not Found
2.복구 불가능한 오류 => 버그(예를들어 어레이의 끝을 넘는 인덱스에 액세스 하려는 경우)
대부분의 언어는 위의 2가지를 구분하지 않고 예외처리를 이용함 하지만 RUST는 예외를 지원하지 않음 =>대신에 복구 가능한 오류를 다루기위해 Result enum을 사용
pub type Result<T> = result::Result<T, Error>;
를 이용하여 우린 커스텀타입을 정의할 수 있음


*반복문을 이용해 새로운 연결이 있는지 확인해보자
무한반복문 while문도 있지만 loop를 이용
RUST의 loop는 레이블을 지정할 수 있음
'outer: loop {
            loop {
                break 'outer;
            }
        }
이런식으로 하면 안의 loop에서 바깥의 loop를 멈출 수 있음
continue 또한 break와 일치

우리가 반복문을 사용하기전 생각해야될것은 새로운 연결이 있는지 체크를 해야함.
listener.accept();은 새로운 연결이 있는지 청취 -> 새로운 TCP연결이 수립될 때까지는 호출스레드를 차단 Result<(TcpStream, SocketAddr)> 이런식으로 리턴이 되는데
리턴값이 TcpStream,SocketAddr로 튜플형식으로 나옴
    *튜플이란? 다른 타입으로 된 많은 값들을 하나의 복합타입으로 그룹화하는데 사용
    튜퓰은 길이가 정해져있고,선언한 다음에는 길이를 줄이거나 늘릴 수 없음
    let tup = (5, "a", listener); => return값에 (i32, &str, TcpListener)로 정의하면 됨


listener.accept();를 이어서 어떤 이유에서라도 실패했을경우 우리는 프로그램이 종료되길 원하지 않는다.
listener.accept().unwrap();를 사용할 경우 ERROR발생시 프로그램 종료할것이다. => 그래서 우린 unwrap()를 사용하기전 Result가 Err인지 확인해야함

let res = listener.accept();
if res.is_err() {
    continue;
}
let (stream, addr) = res.unwrap();
해당코드는 괜찮은거 같지만,RUST enum 변수를 다루기엔 BEST가 아니다. Result는 간단히 Ok,Err이다.하지만 예를 들어 우리가 Method enum의 변수를 체크해야한다면? 또한 각각에 대한 로직을 구현하려면 수많은 if/else구문을 작성해야할것이다. => 가독성 저하 => RUST에서 강력하고 편리하게 enum을 다루기 위해 "MATCH"가 있다.
*MATHC를 이용하면 어떤값과 일련의 패턴을 비교하고 매칭되는 패턴으로 코드를 실행할 수 있음
match는 enum뿐만 아니라 일반적인 switch문도 작동
match "abcd" {
                "abcd" => println!(),
                "a" | "b" => {},
                _ => {}
            }
이렇게도 가능

--------------------------------------------------------------------------------------------------------------------------------------------------------

Array는 튜플과 마찬가지로 복합 타입
하지만 튜플과 다르게 어레이는 동일한 타입으로 된 값들의 집합
어레이의 구체적인 타입은 항상 그 안에 있는 값의 타입과 거기 포함된 값의 개수를 더한 것! => 이유는 어레이가 정확히 얼마나 큰지 컴파일러가 알아야하기 때문 그래야 스택에 충분한 메모리를 할당할 수 있기 때문이다.
하지만 어레이의 원소가 몇개나 있을지 항상 알아야한다면 이건 너무 힘든 일이기에 => 어레이에 대한 참조를 넣으면 된다 =>컴파일러는 이게 단지 포인터이고 그 포인터가 얼마나 큰지 알게 됨
어레이에서 &[u8]는 슬라이스라고 부름 => 문자열에서도 봤지만 이게 더 제너릭함 그 이유는 어레이에 어떠한 타입도 담을 수 있기에

현재 실행시 Listening on 127.0.0.1:8080이 나오며 끊기지 않는 이유는 loop가 돌고 있어 끊기지 않으며 실행 후 -> terminal에서 echo HIHI | 127.0.0.1 8080 을 하면 메세지를 받았고 로깅하고 있는것을 확인할 수 있음

String::from_utf8 는 바이트가 담긴 버퍼를 파라미터로 예상하고 그 바이트는 유효한 utf-8이어야함! => Result를 리턴하는데 그 이유는 유효하지 않은 utf-8바이트가 포함되어있을 수 있기 때문이다.그러면 연산 전체가 실패가 될 것!

String::from_utf8_lossy 하지만 요청이 유효한 utf-8인지 확인할 필요가 없을 경우에는 사용 =>절대 실패하지 않음


--------------------------------------------------------------------------------------------------------------------------------------------------------
*트레이트 및 타입 변환
우리가 구현하지 않은 별도의 트레이트에 이미 존재하는 타입에 추가로 기능을 더해주게 됨 => 이게 RUST에서 트레이트가 가진 가장 강력한 특징 중 하나! ex)암호화를 위힌 커스텀 트레이트


pub enum ParseError
impl Error for ParseError
Result를 계ㅅ고 사용할 수 있지만 Error 트레이트를 구현함으로써 오류타입에 관한 우리의 기본적인 기대를 우리가 충족하도록 강제하게 됨.
println!(" {}",) 여기서
{}에 {:?}를 할 경우 디버그 트레이트 구현체를 호출


str::from_utf8(buf).or()
.or() 메소드는 만일 호출하는 Result가 오류라면 우리가 넣어준 Result를 리턴
Result가 OK라면 그냥 언래핑하고 Ok() 안에 있는 값을 리턴할 것이다.

방식1. match str::from_utf8(buf) {
    Ok(request) => {},
    Err(_) => return Err(ParseError::InvalidEncoding),
}
방식2. match str::from_utf8(buf).or(Err(ParseError::InvalidEncoding)) {
    Ok(request) => {},
    Err(e) => return Err(e),
}

str::from_utf8(buf).or(Err(ParseError::InvalidEncoding))?
?(물음표 연산자)를 붙이면 이 매칭 구문이 하는 일과 거의 비슷한 일을 함
=>Result가 Ok면 그냥 Ok()가 감싸고 있는 값을 리턴
=>Result가 Error면 그냥 Ok()가 감싸고 있는 값을 리턴
=>Result가 Error면 우리 함수에서 오류를 리턴할 것이다.

물음표와 아닌것의 차이는 물음표는 함수가 리턴할 오류 타입이 매칭되지 않으면 그게 받는 오류 타입을 변환하려 할 것이다.


Request.chars();는 RUST의 이터레이터는 다른 언어의 이터레이터와 유사.
그냥 .next()가 붙어있는 메소드이며 우리가 매번 next()를 호출할 때마다 Option을 돌려받게 됨
이 Option에는 다음 원소가 담겨 있거나 None이 될것이다.

문자열에 대해 범위를 사용할때 인덱스만 추가하면 프로그램이 충돌하게될 수 있음. => RUST의 모든 문자열은 유효하게 utf-8로 인코딩 되어 있어야하기 때문이다.
그래서 &reqeust[..i], &reqeust[i+1..]를 했을경우 i+1이 문자 1개를 추가한다는게 아닌 1바이트를 추가한다는 뜻이며 그 다음 문자가 1바이트보가 크고 예를들어 이모티콘이나 키릴문자이면 
유효하지 않은 utf-8 문자열을 생성하게 되며,결국 우리는 충돌하게 됨

방식1. match get_next_word(reqeust) {
            Some((method, request)) => {},
            None => return  Err(ParseError::InvalidRequest),
        }

방식2. let (method, request) = get_next_word(reqeust).ok_or(ParseError::InvalidRequest)?;

위아래 같은거임

여기서 우리가 주의할 점은 우리가 이런 let 구문에 기존의 변수 이름을 다시 사용하면 request 변수를 덮어쓴다는 점이다.우리는 기존 변수에 새로운 값을 지정하지 않고 전혀 새로운 변수를 만들고
있습니다.이게 같은 이름으로 기존 것은 이제 더 이상 사용할 수 없다.
=> 이렇게 로컬 변수의 이름을 다시 사용하는걸 변수 섀도잉이라고 부른다

방법1. match path.find('?') {
    Some(i) => {
        query_string = Some(&path[i+1..]);
        path = &path[..i];
    },
    None => {}
}

방법2. let q = path.find('p');
if q.is_some() {
    let i = q.unwrap();
    query_string = Some(&path[i+1..]);
    path = &path[..i];
}

방법3. if let Some(i) = path.find('?') {
    query_string = Some(&path[i+1..]);
    path = &path[..i];
}

여기서 가장 베스트 방법은 3번이며 그 이유는 
1.None => {} 같은 불필요한 암 매칭이 필요없다
2.코드가 깔끔해진다.
3.불필요한 많은 변수나 언래핑을 줄일 수 있다.
방법3을 하면 우리가 관심을 갖는 변수에만 매칭하고 다른 모든건 완전히 무시할 수 있게 됨!

현재 코드로 봤을때 현재는 buffer로 부터 구조체를 만들때
1.Method enum을 생성하고,
2.경로와 쿼리문자열에 대해선 우리는 실제로 경로의 모든 내용을 복사하고
3.새로운 문자열을 만들기 위한 새로운 위치 힙을 만들고 그걸 힙에 복사

여기서 buffer에서 힙의 새로운 문자열로 복사할때의 이점은 Request가 이제 두 문자열을 소유하게됨.
=> 그러므로 Request가 원한다면 변경할 수 있게된다. 하지만 우리는 변경하지도 않을뿐더라 우리의 목적은 네트워크를 통해 어떤걸 받는것이다 => JUST 읽기만 원한다!
그래서 문자열들을 복사하고 불필요한 위치에 힙을 만드는건 합리적이지 않다
그리하여 우리는 문자열 슬라이스를 Request 구조체 안에 직접 저장할 수 있음 그리고 버퍼를 다시 지시할것이다.그러면 불 필요한 위치의 힙이 없고,바이트를 복사할 필요도 없다.

--------------------------------------------------------------------------------------------------------------------------------------------------------

*변수의 수명
일반적으로 우리는 변수의 수명에 대해 생각할 필요가 없다.특히 가비지 컬렉터가 있는 언어에서 말이다.
RUST에선 어레이와 그걸 지시하는 참조의 수명에 대해 생각하도록 강요.그리고 우리는 참조가 실제 어레이보다 오래 사는지 컴파일러가 정적으로 체크하는데 필요한 정보를 컴파일러가 갖고 있는지 확인해야함

보통 수명은 글자 하나로 표시하고 예를 들면 a라고 함 그리고 이름을 정하기 위해 우리는 <'a> 이런식으로 표현
함수가 리턴하는 참조의 수명은 파라미터로서 들어간 참조의 수명과 같다. => 파라미터가 한개이 경우 <'a>와 같은 명시적인 수명을 제공할 필요가 없다 왜냐하면 뭘 리턴하든지 간에 함수가 받은 파라미터의 수명과 같기 때문.
1.수명은 RUST컴파일러가 메모리 안전을 보장할 수 있게하는 강력한 도구다!
2.우리가 명시적으로 지정하는 수명 파라미터는 어떤 값의 수명이 얼마나 길지 우리가 선택하도록 허용하지 않는다! 단지 어떤 참조는 동일한 메모리에 관련되어 있고 동일한 수명을 공유할걸로 예상된다는걸 우리가 컴파일러에게 알려주도록 한다.
