콘솔에서 사용자의 입력을 읽고 대답을 출력하는 간단한 명령줄 애플리케이션
-Functions
-Basic Data Types
-Standard Library (표준 라이브러리와 가장 중요한 메모리 소유권 규칙)
-Memory Ownership

내가 해볼건 화성에서의 무게 계산기이다.
사용자가 지구에서의 본인 무게를 제공하면 프로그램은 화성의 무게로 출력해줄것이다.


1.Basic Data Types
-Booleans
-Characters
-Integers
-Floats

데이터 유형이 - u로 시작하면 무부호 정수 (Only 양수)
           - i로 시작하면 유부호 정수 (양수 / 음수 둘다 됨)

u8,i8 = 8bit 숫자 또는 1byte
u16, i16 
u32, i32 
u64, i64 
u128, i128  = 128bit


8bit = 1byte -> 알파벳,숫자,기본 특수 문자
한글은 보통 한글자에 3바이트 정도 됨

러스트에는 usize, isize가 있음 -> 아키텍쳐에 종속된 타입으로 32bit 아키텍쳐환경에선 32bit , 64bit 아키텍쳐환경에선 64bit
러스트에는 두 종류의 부동 소수점 숫자가 존재,32bit인 f32 64bit인 f64가 존재
러스트에서 bool은 1byte
러스트에서 char은 하나의 유니코드 값을 갖는다.(4byte) -> ASCII 문자집합을 char로 저장한다면 메모리를 낭비하게 됨

------------------------------------------------------------------------------------------------------------------------------

함수
fn으로 함수가 시작되며
항상 러스트 파일이 실행될때 제일 먼저 실행되는 코드는 main() -> 프로그램의 시작점
또한 러스트 코드는 함수와 변수명을 스네이크 케이스를 사용
매개변수는 꼭 타입지정 -> 컴파일러는 각 함수에 대해 스택 프레임의 크기를 알고 이 스택 프레임에 들어갈 모든 변수의 크기를 알아야하기 때문.

------------------------------------------------------------------------------------------------------------------------------

매크로 -> 메타 프로그래밍 -> 더 많은 코드를 작성하는 코드 작성 방법 중 하나
매크로의 장점 변수,다수의 매개변수 그리고 매번 다른 유형의 처리
매크로의 단점 매크로를 정의하는 것이 함수 정의보다 더 복잡하다
예로서 println!("Number: {}, String: {}", 100, "abc"); 를 출력하면 Number: 100, String: abc이 나옴

------------------------------------------------------------------------------------------------------------------------------

러스트에 있는 모든 변수들은 기본적으로 불변 변수라는 뜻
일단 변수에 값을 할당하면,절대 변경될 수 없다는 뜻!
가변 변수로 만들려면 반드시 명시적 선언이 필요
let mut mars_weight 이런식으로 mut를 선언해줘야함

------------------------------------------------------------------------------------------------------------------------------
io::stdin().read_line(&mut input);
에서 &mut란?
러스트에는 세가지 소유권 규칙이 존재.

1.Each value in Rust is owned ny a variable.
러스트에서 각각의 값은 변수가 소유한다는것.

2.When the owner goes out of scope, the value will be deallocated.
소유자가 범의를 벗어나면 그 값은 해제.

3.There can only be ONE onwer at a time.
특정 시점에 값의 소유자는 단 하나뿐이다.

fn main() {
    let mut input = String::new();
    some_fn(input);
    //input은 문자열 String의 소유자 및 문자열에 대한 포인터
    //컴파일 시점에 문자열의 크기를 알지 못하기 때문에 힙에 저장 -> 스택에는 힙을 가리키는 포인터를 저장.문자열의 크기 같은 메타데이터를 추가로 저장
    //input이 범위를 벗어나면,힙에 있는 문자열은 해제
    // let mut s = input;
    // 이럴경우 두 소유자가 생기는데
    //범위에 벗어나다 = 함수가 끝나다로 봤을때 -> 문자열을 해제 -> 그럼 이중 해제를 하게되는데 메모리 손상을 일으킬 수 있음 그래서 심각한 보안 취약점이 될 수 있음
    io:: stdin().read_line(&mut input);
    
    let mut mars_weight = calculate_weight_on_mars(100.0);
    // println!("Number: {}, String: {}", 100, "abc");
    mars_weight = mars_weight * 1000.0;
    println!("Weight on Mars: {}kg", mars_weight);

}

fn calculate_weight_on_mars(weight: f32) -> f32 {
    (weight / 9.81) * 3.711
}

fn some_fn(s: String) {}

// some_fn을 만들어서 input을 호출했을때 이 문자열의 소유권이 some_fn의 변수 s로 되었기에
// some_fn함수가 끝날때 문자열은 해제됨으로 이 포인터는 더이상 유효하지 않게됨 -> 메모리주소에 있지 않고 그 안에 뭐가 있는지 모르게 됨 -> 메모리 손상되고 프로그램은 동작하지 않는다. 
// 그래서 러스트 컴파일러는 이런 오류를 막기 위해 단일 소유자 규칙을 강제 적용하고 있음
// 그러므로 매개 변수를 함수에 전달하고 이 함수 반환 이후에도 계속 사용할 수 있도록 한다는 뜻 -> 이것만이 아니라 이걸 보완하기위해 차용이라는 기능이 있음


------------------------------------------------------------------------------------------------------------------------------
참조와 차용

러스트에는 소유권 이전 없이 함수에 변수를 전달하는 방법으로 참조라는 기능이 있음.
참조는 소유권없이 값을 참조할 수 있게 해줌

fn some_fn(s: &String)
를 해줌으로써 참조할 수 있게됨 변수 s가 범위를 벗어나도,문자열은 제거되지 않는데 => 변수 s가 문자열의 소유자가 아니기 때문이다. => 함수는 문자열을 차용만 함
러스트에서는 매개변수로 참조를 전달하는 것을 차용이라고 함
하지만 일반적인 변수처럼,참조는 기본적으로 변경이 불가능함 (ex: s.push_str("a");)

참조 유형의 또 다른것으로 가변 참조가 있음. &기호 다음에 키워드 mut를 붙여줌

참조에는 중요한 규칙이 있다.동일한 범위 안에서는 원하는 만큼의 불변 참조 또는 단일 가변 참조를 가질 수 있다.
let mut s1 = &mut input;
let s2 = &input;
컴파일러는 가변 차용과 불변 차용이 동시에 일어나는것을 허용하지 않는다.
가변 차용을 했으면,다른 차용을 할 수 없음.하지만 s2를 s1과 마찬가지로 가변으로 변환해서 한다면 
이 역시 또한 불가능함 => 왜냐하면 단일 가변 차용만 허용 => 불편하긴 하나 이런 제한은 컴파일 시점에 데이터 레이스를 방지하는 장점을 갖는다.다른 언어에서 동시 실행 코드를 작성할때는 항상 데이터 레이스에 대해 생각하고 방지할 수 있는 방법을 생각해야함.하지만 러스트는 이런 점 때문에 컴파일이 된다면 데이터 레이스가 일어날 일이 없다는것을 정적으로 보장
 let mut input = String::new(); //가변 참조
let s1 = &input; //불변 참조
let s2 = &input; //불변 참조
println!("{} {}",s1,s2);
컴파일 됨
let mut input = String::new(); //가변 참조
    let s1 = &input; //불변 참조
    let s2 = &input; //불변 참조
    some_fn(&mut input);
    println!("{} {}",s1,s2);
컴파일 안됨
    some_fn(&mut input);여기서 $mut로 가변참조가 일어나기 떄문