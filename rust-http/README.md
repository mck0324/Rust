이번 프로젝트에선
RUST & HTTP/1.1 서버 구현해보기
HTTP/1.1은
1.어플리케이션 레이어 프로토콜 또는 L7 프로토콜
2.TCP클라이언트 서버를 통해 전송
3.스트리밍 데이터가 아닌 개별 메세지를 교환해서 통신

----------------------------------------------------------------------------

러스트에는 두가지 타입의 문자열이 있음
str은 문자열 슬라이스 -> 어떤 문자열에 대한 이뮤터블한 참조

새로운 문자열을 만들려면 let string = String::new() 함수 호출
let string = String::from()도 존재
문자열 슬라이스를 이용하면 우리가 서버에서 받을 요청들을 효율적으로 분해할 수 있음.
만약 문자열 슬라이스를 받는 함수에 문자열을 넣으려고 한다면,컴파일러는 문자열을 문자열 슬라이스로 변환하고 그러 함수에 넣어줌
let string_literal = "1234"; 같은 경우에 컴파일링 시점에 이미 string_literal이 알려져 있기 때문에 우린 코드를 컴파일링 하기 전에 컴파일러에게 그걸 알려준다. => 그럼 컴파일러는 이걸 바이너리 자체로 구워낸다. => 이 문자열이 실제로 있는 곳은 메모리 안 일 것이다.

let string_slice = &string[10..]; 이런 리터럴 인덱스를 이용해서 문자열을 자르고 싶지 않다. => 러스트의 모든 문자열은 UTF-8로 인코딩 되어 있기 때문 => 문자열에 있는 한 문자가 항상 1바이트를 차지하는지 확실하지 않다는 의미. => 보통은 알파벳,숫자 등은 1바이트로 되어있지만 일본어 기호,이모티콘 같은건 1바이트 이상을 차지하는 경우가 있어 let string = String::from("🚚🎱👸🔥");  [src/main.rs:8:5] string_slice = "🚚" 이런 경우가 있음
이모티콘은 1바이트가 아닌 4바이트로 인코딩 되기 때문이다.
그래서 일반적으로 우리가 실제 애플리케이션을 작성할때 이렇게 직접 문자열을 자르지 않길 원함.

----------------------------------------------------------------------------

GET /user?id=10 HTTP/1.1\r\n
HEADERS \r\n
BODY
구현해보자

ENUM은 유한한 값 집합을 갖고 있는 툭수한 타입  RUST의 ENUM은 Haskell의 대수 자료형과 아주 비슷함
메모리 안에서는 enum의 베리언트가 단순한 숫자로 표시
enum Method {
    GET,
    DELETE,
    POST,
    PUT,
    HEAD,
    CONNECT,
    OPTIONS,
    TRACE,
    PATCH,
    
}
를 봤을때 Method가 GET이라면 메모리에서 우린 그냥 0을 저장,DELETE라면 1을 저장

RUST는 NO VALUE를 지원하지 않는다.하지만 비록 RUST가 언어에서 NO를 삭제하기로 했지만 값이 없다는걸 어떻게든 표현하길 원함 => RUST는 완벽히 타입에 안전한 방식으로 그걸함,표준 라이브러리의 특수 enum인 Option을 사용
query_string: Option<String>는 이게 String에 대해 제네릭한 Option이라는걸 컴파일러에게 알려주는것! -> 컴파일러는 String을 담는 Option enum에 필요한 공간을 할당
이런 방식으로 하면 우리는 예외가 발생할 걸 걱정하지 않고 타입에 대해 안전한 방식으로 값이 어떻게 표현되는지 알 수 있음

--------------------------------------------------------------------------------------------------------------------------------------------------------
점점 main.rs에 파일이 커지고 있어 -> 프로그램이 커지면 그걸 둘 이상의 파일로 나누고 기능과 타입들을 다른 네임스페이스에 넣어줄 필요가 있음 -> RUST에선 모듈이라고 부름 
모듈은 아이템들의 가시성을 통제함 뿐만 아니라 즉 아이템의 코드를 바깥에서도 사용할 수 있는지를 말함
폴더를 만들고 모듈을 분리함으로써 가독성 , 코드가 다수의 모듈로 정리가 됨 => 모듈은 정리하고 가시성을 높이자!!


--------------------------------------------------------------------------------------------------------------------------------------------------------
TCP연결

TcpListener는 Result을 리턴 => Result리턴은 RUST에서 오류처리(에러핸들링)의 핵심

RUST가 다른언어와 다른점은 RUST는 우리가 오류의 가능성을 인식하고 코드가 성공적으로 컴파일링 되기전 약간의 조치를 취하길 요구한다는 점이다! 이를 통해 우리는 오류를 적절히 처리하게 함으로써 프로그램을 더욱 강건하게 만들어준다
RUST의 오류는 두가지로 구분.
1.복구 가능한 오류 => File Not Found
2.복구 불가능한 오류 => 버그(예를들어 어레이의 끝을 넘는 인덱스에 액세스 하려는 경우)
대부분의 언어는 위의 2가지를 구분하지 않고 예외처리를 이용함 하지만 RUST는 예외를 지원하지 않음 =>대신에 복구 가능한 오류를 다루기위해 Result enum을 사용
pub type Result<T> = result::Result<T, Error>;
를 이용하여 우린 커스텀타입을 정의할 수 있음


*반복문을 이용해 새로운 연결이 있는지 확인해보자
무한반복문 while문도 있지만 loop를 이용
RUST의 loop는 레이블을 지정할 수 있음
'outer: loop {
            loop {
                break 'outer;
            }
        }
이런식으로 하면 안의 loop에서 바깥의 loop를 멈출 수 있음
continue 또한 break와 일치

우리가 반복문을 사용하기전 생각해야될것은 새로운 연결이 있는지 체크를 해야함.
listener.accept();은 새로운 연결이 있는지 청취 -> 새로운 TCP연결이 수립될 때까지는 호출스레드를 차단 Result<(TcpStream, SocketAddr)> 이런식으로 리턴이 되는데
리턴값이 TcpStream,SocketAddr로 튜플형식으로 나옴
    *튜플이란? 다른 타입으로 된 많은 값들을 하나의 복합타입으로 그룹화하는데 사용
    튜퓰은 길이가 정해져있고,선언한 다음에는 길이를 줄이거나 늘릴 수 없음
    let tup = (5, "a", listener); => return값에 (i32, &str, TcpListener)로 정의하면 됨


listener.accept();를 이어서 어떤 이유에서라도 실패했을경우 우리는 프로그램이 종료되길 원하지 않는다.
listener.accept().unwrap();를 사용할 경우 ERROR발생시 프로그램 종료할것이다. => 그래서 우린 unwrap()를 사용하기전 Result가 Err인지 확인해야함

let res = listener.accept();
if res.is_err() {
    continue;
}
let (stream, addr) = res.unwrap();
해당코드는 괜찮은거 같지만,RUST enum 변수를 다루기엔 BEST가 아니다. Result는 간단히 Ok,Err이다.하지만 예를 들어 우리가 Method enum의 변수를 체크해야한다면? 또한 각각에 대한 로직을 구현하려면 수많은 if/else구문을 작성해야할것이다. => 가독성 저하 => RUST에서 강력하고 편리하게 enum을 다루기 위해 "MATCH"가 있다.
*MATHC를 이용하면 어떤값과 일련의 패턴을 비교하고 매칭되는 패턴으로 코드를 실행할 수 있음
match는 enum뿐만 아니라 일반적인 switch문도 작동
match "abcd" {
                "abcd" => println!(),
                "a" | "b" => {},
                _ => {}
            }
이렇게도 가능

--------------------------------------------------------------------------------------------------------------------------------------------------------

Array는 튜플과 마찬가지로 복합 타입
하지만 튜플과 다르게 어레이는 동일한 타입으로 된 값들의 집합
어레이의 구체적인 타입은 항상 그 안에 있는 값의 타입과 거기 포함된 값의 개수를 더한 것! => 이유는 어레이가 정확히 얼마나 큰지 컴파일러가 알아야하기 때문 그래야 스택에 충분한 메모리를 할당할 수 있기 때문이다.
하지만 어레이의 원소가 몇개나 있을지 항상 알아야한다면 이건 너무 힘든 일이기에 => 어레이에 대한 참조를 넣으면 된다 =>컴파일러는 이게 단지 포인터이고 그 포인터가 얼마나 큰지 알게 됨
어레이에서 &[u8]는 슬라이스라고 부름 => 문자열에서도 봤지만 이게 더 제너릭함 그 이유는 어레이에 어떠한 타입도 담을 수 있기에

현재 실행시 Listening on 127.0.0.1:8080이 나오며 끊기지 않는 이유는 loop가 돌고 있어 끊기지 않으며 실행 후 -> terminal에서 echo HIHI | 127.0.0.1 8080 을 하면 메세지를 받았고 로깅하고 있는것을 확인할 수 있음

String::from_utf8 는 바이트가 담긴 버퍼를 파라미터로 예상하고 그 바이트는 유효한 utf-8이어야함! => Result를 리턴하는데 그 이유는 유효하지 않은 utf-8바이트가 포함되어있을 수 있기 때문이다.그러면 연산 전체가 실패가 될 것!

String::from_utf8_lossy 하지만 요청이 유효한 utf-8인지 확인할 필요가 없을 경우에는 사용 =>절대 실패하지 않음


--------------------------------------------------------------------------------------------------------------------------------------------------------
*트레이트 및 타입 변환
우리가 구현하지 않은 별도의 트레이트에 이미 존재하는 타입에 추가로 기능을 더해주게 됨 => 이게 RUST에서 트레이트가 가진 가장 강력한 특징 중 하나! ex)암호화를 위힌 커스텀 트레이트


pub enum ParseError
impl Error for ParseError
Result를 계ㅅ고 사용할 수 있지만 Error 트레이트를 구현함으로써 오류타입에 관한 우리의 기본적인 기대를 우리가 충족하도록 강제하게 됨.
println!(" {}",) 여기서
{}에 {:?}를 할 경우 디버그 트레이트 구현체를 호출


